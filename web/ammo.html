<head>
    <!-- Source: https://en.threejs-university.com/2021/08/27/three-js-physics-ammo-js/ -->
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />

  <style>
    body
    {
        margin: 0; touch-action: none;
        background-image: -webkit-gradient(linear, 0 0, 100% 100%, color-stop(0, #877fa8), color-stop(100%, #f9ae91));
        background-image: -webkit-linear-gradient(135deg, #877fa8, #f9ae91);
        background-image: -moz-linear-gradient(45deg, #877fa8, #f9ae91);
        background-image: -ms-linear-gradient(45deg, #877fa8 0, #f9ae91 100%);
        background-image: -o-linear-gradient(45deg, #877fa8, #f9ae91);
        background-image: linear-gradient(135deg, #877fa8, #f9ae91);
    }

    canvas { width: 100%; height: 100% ; touch-action: none;}
  </style>

  <script src="/js/ammo.js"></script>
  <!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "/jsm/three.module.js"
				}
			}
		</script>

  <script  type="module">
    import * as THREE from '/jsm/three.module.js';
		import { PointerLockControls } from '/jsm/controls/PointerLockControls.js';
    import Stats from '/jsm/libs/stats.module.js';
    import { GUI } from '/jsm/libs/lil-gui.module.min.js';
		import { GLTFLoader } from '/jsm/loaders/GLTFLoader.js';

    // Ammo.js
    let physicsUniverse, tmpTransformation, dispatcher;
    var rigidBody_List = new Array();
    // Three.js global variables
    let scene, camera, renderer, clock, controls;
    let stats, model,face, gui, mixer, actions, activeAction, previousAction;
		const api = { state: 'Walking' };
    // Maze
    const mazeWidth = 80, mazeDepth = 80, size=mazeWidth*mazeDepth, mazeCell=8;
    const data = [];
    
    // Read the maze from png (80x80 as the world)
    const loader = new THREE.ImageLoader();
    // load a image resource
    loader.load(
      // resource URL
      '/static/maze.png',
      // onLoad callback
      function ( image ) {
        const canvas = document.createElement( 'canvas' );
        canvas.width = image.width;
        canvas.height = image.height;
        
        const context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0 );

        // data2 is in RGBA
        const data2 = context.getImageData( 0, 0, canvas.width, canvas.height );
        //console.log( data2 );
                
        for ( let i = 0; i < size; i ++ ) {
          const R = data2.data[4*i];
          const G = data2.data[4*i+1];
          const B = data2.data[4*i+2];
          const Gray = (R+G+B) / 3;
          if ( Gray < 128 )
            data[i] = 1;
          else
            data[i] = 0;
        }
        // Load ammo then start 
        Ammo().then( AmmoStart );
      },
      // onProgress callback currently not supported
      undefined,
      // onError callback
      function () {
        console.error( 'Couldnt read the maze.' );
      }
    ); 

    
    function AmmoStart() {
      tmpTransformation = new Ammo.btTransform();
      initPhysicsUniverse();
      initGraphicsUniverse();
      // base
      createCube(80 , new THREE.Vector3(0, -80, 0) , 0 );
      // maze cubes
      for ( let x = 0; x < mazeWidth; x += mazeCell ) {
        for (let z = 0; z < mazeDepth; z += mazeCell) {
          let val = data[x*mazeWidth + z];
          if (val === 1) {
            // place a cube at this position 
            createCube(1 , new THREE.Vector3(x, 10, z) , 1, null );
          }
        }
      }

      /*
        // falling cubes
      createCube(4 , new THREE.Vector3(0, 10, 0) , 1, null );
      createCube(2 , new THREE.Vector3(10, 30, 0) , 1, null );
      createCube(4 , new THREE.Vector3(10, 20, 10) , 1, null );
      createCube(6 , new THREE.Vector3(5, 40, 20) , 1, null );
      createCube(8 , new THREE.Vector3(25, 100, 5) , 1, null );
      createCube(8 , new THREE.Vector3(20, 60, 25) , 1, null );
      createCube(4 , new THREE.Vector3(20, 100, 25) , 1, null );
      createCube(2 , new THREE.Vector3(20, 200, 25) , 1, null );*/
      render();
    }
    
    // ------ Physics World setup ------
    function initPhysicsUniverse() {
      var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      var overlappingPairCache = new Ammo.btDbvtBroadphase();
      var solver = new Ammo.btSequentialImpulseConstraintSolver();
      physicsUniverse = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsUniverse.setGravity(new Ammo.btVector3(0, -75, 0));
    }  
  
      
    // ------ Three.js setup ------
    function initGraphicsUniverse() {
      // Three.js scene
      scene = new THREE.Scene();
      // clock
      clock = new THREE.Clock();
      // camera
      camera = new THREE.PerspectiveCamera( 60, window.innerWidth /     window.innerHeight, 1, 1000 );
      camera.position.set( -25, 20, -25 );
      camera.lookAt(new THREE.Vector3(0, 6, 0));
      // renderer
      renderer = new THREE.WebGLRenderer({antialias : true, alpha : true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement) ;
      // light
      var ambientLight = new THREE.AmbientLight(0xcccccc, 0.2);
      scene.add(ambientLight);
      var directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(-1, 0.9, 0.4);
      scene.add(directionalLight);
      // Load player model
      const loader = new GLTFLoader();
      loader.load( '/static/RobotExpressive.glb', function ( gltf ) {
        model = gltf.scene;
        scene.add( model );
        createGUI( model, gltf.animations );
      }, undefined, function ( e ) {
        console.error( e );
      } );
      // controls
      controls = new PointerLockControls( camera, renderer.domElement );
      const blocker = document.getElementById( 'blocker' );
      const instructions = document.getElementById( 'instructions' );

      instructions.addEventListener( 'click', function () {

        controls.lock();

      } );

      controls.addEventListener( 'lock', function () {

        instructions.style.display = 'none';
        blocker.style.display = 'none';

      } );

      controls.addEventListener( 'unlock', function () {

        blocker.style.display = 'block';
        instructions.style.display = '';

      } );

      scene.add( controls.getObject() );
      /*controls.movementSpeed = 10;
      controls.lookSpeed = 0.100;
      controls.lookVertical = false;
      controls.enableDamping = true;
      controls.autoForward = false;*/
      // stats
			stats = new Stats();
			document.body.appendChild( stats.dom );
    }
      
    // CreateCube
    function createCube(scale , position, mass, rot_quaternion) {
      let quaternion = undefined;
      if(rot_quaternion == null) {
          quaternion = {x: 0, y: 0, z: 0, w:  1};
      }
      else {
        quaternion = rot_quaternion;
      }
  
      // ------ Graphics Universe - Three.JS ------
      let newcube = new THREE.Mesh(new THREE.BoxBufferGeometry(scale, scale, scale), new THREE.MeshPhongMaterial({color: Math.random() * 0xffffff}));
      newcube.position.set(position.x, position.y, position.z);
      scene.add(newcube);
  
      // ------ Physics Universe - Ammo.js ------
      let transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin( new Ammo.btVector3( position.x, position.y, position.z ) );
      transform.setRotation( new Ammo.btQuaternion( quaternion.x, quaternion.y, quaternion.z, quaternion.w ) );
      let defaultMotionState = new Ammo.btDefaultMotionState( transform );
      // geometric collision
      let structColShape = new Ammo.btBoxShape( new Ammo.btVector3( scale*0.5, scale*0.5, scale*0.5 ) );
      structColShape.setMargin( 0.05 );
      // initial inertia
      let localInertia = new Ammo.btVector3( 0, 0, 0 );
      structColShape.calculateLocalInertia( mass, localInertia );
      // the rigid body
      let RBody_Info = new Ammo.btRigidBodyConstructionInfo( mass, defaultMotionState, structColShape, localInertia );
      let RBody = new Ammo.btRigidBody( RBody_Info );
      // add to physical universe
      physicsUniverse.addRigidBody( RBody );
      newcube.userData.physicsBody = RBody;
      newcube.userData.physicsBody = RBody;
      rigidBody_List.push(newcube);
    }
  
    // Update physical universe
    function updatePhysicsUniverse( deltaTime ) {
      physicsUniverse.stepSimulation( deltaTime, 10 );
      for ( let i = 0; i < rigidBody_List.length; i++ ) {
        let Graphics_Obj = rigidBody_List[ i ];
        let Physics_Obj = Graphics_Obj.userData.physicsBody;
        let motionState = Physics_Obj.getMotionState();
        if ( motionState ) {
          motionState.getWorldTransform( tmpTransformation );
          let new_pos = tmpTransformation.getOrigin();
          let new_qua = tmpTransformation.getRotation();
          Graphics_Obj.position.set( new_pos.x(), new_pos.y(), new_pos.z() );
          Graphics_Obj.quaternion.set( new_qua.x(), new_qua.y(), new_qua.z(), new_qua.w() );
        }
      }
      detectCollision();
    }

    function detectCollision() {
    	let dispatcher = physicsUniverse.getDispatcher();
    	let numManifolds = dispatcher.getNumManifolds();
    
    	for ( let i = 0; i < numManifolds; i ++ ) {
    		let contactManifold = dispatcher.getManifoldByIndexInternal( i );
    		let numContacts = contactManifold.getNumContacts();
    		for ( let j = 0; j < numContacts; j++ ) {
    			let contactPoint = contactManifold.getContactPoint( j );
    			let distance = contactPoint.getDistance();
    			//console.log({manifoldIndex: i, contactIndex: j, distance: distance});
    		}
    	}
    }

    // Animation GUI
    function createGUI( model, animations ) {
      const states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing' ];
      const emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];
      gui = new GUI();
      mixer = new THREE.AnimationMixer( model );
      actions = {};
      for ( let i = 0; i < animations.length; i ++ ) {
        const clip = animations[ i ];
        const action = mixer.clipAction( clip );
        actions[ clip.name ] = action;
        if ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {
          action.clampWhenFinished = true;
          action.loop = THREE.LoopOnce;
        }
      }

      // states
      const statesFolder = gui.addFolder( 'States' );
      const clipCtrl = statesFolder.add( api, 'state' ).options( states );
      clipCtrl.onChange( function () {
        fadeToAction( api.state, 0.5 );
      } );
      statesFolder.open();

      // emotes
      const emoteFolder = gui.addFolder( 'Emotes' );
      function createEmoteCallback( name ) {
        api[ name ] = function () {
          fadeToAction( name, 0.2 );
          mixer.addEventListener( 'finished', restoreState );
        };
        emoteFolder.add( api, name );
      }

      function restoreState() {
        mixer.removeEventListener( 'finished', restoreState );
        fadeToAction( api.state, 0.2 );
      }

      for ( let i = 0; i < emotes.length; i ++ ) {
        createEmoteCallback( emotes[ i ] );
      }
      emoteFolder.open();

      // expressions
      face = model.getObjectByName( 'Head_4' );
      const expressions = Object.keys( face.morphTargetDictionary );
      const expressionFolder = gui.addFolder( 'Expressions' );
      for ( let i = 0; i < expressions.length; i ++ ) {
        expressionFolder.add( face.morphTargetInfluences, i, 0, 1, 0.01 ).name( expressions[ i ] );
      }

      activeAction = actions[ 'Walking' ];
      activeAction.play();
      expressionFolder.open();
    }

    function fadeToAction( name, duration ) {
      previousAction = activeAction;
      activeAction = actions[ name ];
      if ( previousAction !== activeAction ) {
        previousAction.fadeOut( duration );
      }
      activeAction
        .reset()
        .setEffectiveTimeScale( 1 )
        .setEffectiveWeight( 1 )
        .fadeIn( duration )
        .play();
    }
    
    // Render
    function render() {
      let deltaTime = clock.getDelta();
      updatePhysicsUniverse( deltaTime );
      renderer.render( scene, camera );
      requestAnimationFrame( render );
			controls.update( deltaTime );
      stats.update();
			if ( mixer ) mixer.update( deltaTime );
    }
    
  </script>
  
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <p style="font-size:36px">
        Click to play
      </p>
      <p>
        Move: WASD<br/>
        Jump: SPACE<br/>
        Look: MOUSE
      </p>
    </div>
  </div>

</body>

</html>
